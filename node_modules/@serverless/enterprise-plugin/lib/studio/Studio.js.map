{"version":3,"sources":["../../../lib/studio/Studio.js"],"names":["Studio","constructor","sdk","sls","serverlessExec","appState","isDeploying","isFunctionDeploying","functions","resources","endpoints","refreshAppState","info","output","updateAppState","updates","publishAppState","overrides","publishSync","event","data","connect","orgName","service","org","onEvent","clientType","isWebConnected","isCliConnected","invoke","e","cli","log","deploy","isRedeploying","functionName","deployToStage","hasDeployFailed","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\nclass Studio {\n  constructor({ sdk, sls, serverlessExec }) {\n    this.sdk = sdk;\n    this.serverlessExec = serverlessExec;\n    this.sls = sls;\n    this.appState = {\n      /**\n       * This is a 'sls deploy' (not a function deploy). It's required\n       * for the initial build, and also any changes to the the serverless.yml\n       * file\n       */\n      isDeploying: false,\n\n      /**\n       * Mapping of (function name) <String> -> <Boolean>\n       * to determine if a function is already deploying\n       */\n      isFunctionDeploying: {},\n\n      /**\n       * These are populated from the 'sls dev --info' output, which\n       * is a combination of a parsed serverless.yml, and outputs\n       * from 'serverless info' (namely the endpoints)\n       */\n      functions: {},\n      resources: {},\n      endpoints: [],\n    };\n  }\n\n  async refreshAppState() {\n    const { output } = await this.serverlessExec.info();\n    this.updateAppState(output);\n  }\n\n  updateAppState(updates = {}) {\n    this.appState = {\n      ...this.appState,\n      ...updates,\n    };\n  }\n\n  async publishAppState(overrides = {}) {\n    await this.sdk.publishSync({\n      event: 'studio.state',\n      data: {\n        ...this.appState,\n        ...overrides,\n      },\n    });\n  }\n\n  async connect() {\n    await this.sdk.connect({\n      orgName: this.sls.service.org,\n      onEvent: async ({ event, data }) => {\n        const { clientType } = data;\n\n        if (event === 'studio.connect') {\n          /**\n           * If a web client connects to the socket, then send the appState. Also issue\n           * another 'studio.connect' to communicate the the CLI is in watch mode. This\n           * will handle a case where the web client refreshes.\n           */\n          if (clientType === 'web') {\n            this.updateAppState({ isWebConnected: true });\n            await this.sdk.publishSync({ event: 'studio.connect', data: { clientType: 'cli' } });\n            await this.refreshAppState();\n            await this.publishAppState();\n          }\n\n          if (clientType === 'cli') {\n            this.updateAppState({ isCliConnected: true });\n          }\n        }\n\n        if (event === 'studio.invoke') {\n          try {\n            await this.serverlessExec.invoke(data);\n          } catch (e) {\n            // Error will already get displayed in the CLI\n          }\n        }\n      },\n    });\n    this.sls.cli.log('Connected to the Serverless Platform');\n  }\n\n  async deploy({ isRedeploying, functionName } = {}) {\n    if (this.appState.isDeploying) {\n      return;\n    }\n\n    if (!functionName) {\n      this.sls.cli.log(\n        `${isRedeploying ? 'Re-deploying' : 'Deploying'} to stage \"${\n          this.serverlessExec.deployToStage\n        }\". This may take a few minutes...`\n      );\n    }\n\n    this.updateAppState({ isDeploying: !functionName });\n    await this.publishAppState();\n\n    let hasDeployFailed = false;\n    try {\n      await this.serverlessExec.deploy(functionName);\n    } catch (e) {\n      /**\n       * If 'sls deploy' fails, the error will be reported to the CLI\n       * already. This could happen for many reasons, such as a typo in\n       * the .yml. We should catch here to prevent the rest of the watch\n       * mode from exiting.\n       */\n      hasDeployFailed = true;\n    }\n\n    if (!hasDeployFailed && !functionName) {\n      this.sls.cli.log(`Successfully deployed stage \"${this.serverlessExec.deployToStage}\"`);\n    }\n\n    this.updateAppState({ isDeploying: false });\n\n    await this.refreshAppState();\n    await this.publishAppState();\n  }\n}\n\nmodule.exports = Studio;\n"],"file":"Studio.js"}